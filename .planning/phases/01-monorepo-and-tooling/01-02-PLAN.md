---
phase: 01-monorepo-and-tooling
plan: 02
type: execute
wave: 2
depends_on:
  - 01-01
files_modified:
  - .github/workflows/pr-checks.yml
  - .github/workflows/pr-cleanup.yml
  - .github/workflows/deploy.yml
autonomous: false
requirements:
  - INFR-04

must_haves:
  truths:
    - "Opening a PR triggers GitHub Actions that run lint, typecheck, knip, test, and build"
    - "PR checks workflow deploys preview Workers for all 3 apps with PR-specific names"
    - "PR checks workflow creates a per-PR D1 database for full isolation"
    - "Closing or merging a PR triggers cleanup of preview Workers and PR-specific D1 database"
    - "Merging a PR to main triggers production deployment of all 3 apps via wrangler deploy"
    - "PR shows pass/fail status from the checks workflow"
  artifacts:
    - path: ".github/workflows/pr-checks.yml"
      provides: "PR quality checks and preview deployment"
      contains: "pull_request"
    - path: ".github/workflows/pr-cleanup.yml"
      provides: "Preview resource cleanup on PR close"
      contains: "closed"
    - path: ".github/workflows/deploy.yml"
      provides: "Production deployment on merge to main"
      contains: "push"
  key_links:
    - from: ".github/workflows/pr-checks.yml"
      to: "package.json"
      via: "pnpm scripts"
      pattern: "pnpm (check|build|test|typecheck)"
    - from: ".github/workflows/pr-checks.yml"
      to: "apps/*/wrangler.jsonc"
      via: "wrangler deploy for preview"
      pattern: "wrangler"
    - from: ".github/workflows/deploy.yml"
      to: "apps/*/wrangler.jsonc"
      via: "wrangler deploy for production"
      pattern: "wrangler deploy"
    - from: ".github/workflows/pr-cleanup.yml"
      to: ".github/workflows/pr-checks.yml"
      via: "matching PR-numbered resource names"
      pattern: "pr-.*number"
---

<objective>
Create 3 GitHub Actions workflows: PR checks with preview deploys, PR cleanup, and production deploy on merge.

Purpose: Automate code quality enforcement and deployment so every PR gets validated and preview-deployed, every merge to main auto-deploys to production, and no preview resources leak after PR closure.

Output: 3 workflow files in `.github/workflows/` that implement the full CI/CD pipeline per user decisions.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-monorepo-and-tooling/01-CONTEXT.md
@.planning/phases/01-monorepo-and-tooling/01-RESEARCH.md
@.planning/phases/01-monorepo-and-tooling/01-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create PR checks workflow with preview deploys</name>
  <files>
    .github/workflows/pr-checks.yml
  </files>
  <action>
    Create the PR checks workflow. This is the most complex workflow — it runs quality checks AND deploys preview Workers with a per-PR D1 database.

    **Trigger:** `pull_request` targeting `main` branch (types: opened, synchronize, reopened).

    **Job 1: `quality`** — Code quality checks
    - `runs-on: ubuntu-latest`, `timeout-minutes: 15`
    - Steps:
      1. `actions/checkout@v4`
      2. `pnpm/action-setup@v4` (auto-detects version from `packageManager` field)
      3. `actions/setup-node@v4` with `node-version: 22`, `cache: pnpm`
      4. `pnpm install --frozen-lockfile`
      5. `pnpm biome check .` (lint + format check)
      6. `pnpm tsc --build` (typecheck all workspaces)
      7. `pnpm knip` (dead code detection)
      8. `pnpm dlx sherif@latest` (dependency consistency)
      9. `pnpm test` (run all tests)
      10. `pnpm -r run build` (build all apps)

    **Job 2: `preview-deploy`** — Deploy preview Workers
    - `needs: quality` (only deploy if checks pass)
    - `runs-on: ubuntu-latest`, `timeout-minutes: 10`
    - Environment variables: `PR_NUM: ${{ github.event.pull_request.number }}`
    - Required secrets: `CLOUDFLARE_API_TOKEN`, `CLOUDFLARE_ACCOUNT_ID`
    - Steps:
      1. `actions/checkout@v4`
      2. `pnpm/action-setup@v4`
      3. `actions/setup-node@v4` with `node-version: 22`, `cache: pnpm`
      4. `pnpm install --frozen-lockfile`
      5. **Create per-PR D1 database:**
         ```bash
         DB_NAME="dt65-pr-${PR_NUM}"
         npx wrangler d1 create "$DB_NAME" 2>/dev/null || true
         DB_ID=$(npx wrangler d1 list --json | jq -r ".[] | select(.name == \"$DB_NAME\") | .uuid")
         echo "D1_DB_ID=$DB_ID" >> $GITHUB_ENV
         ```
         Set env vars `CLOUDFLARE_API_TOKEN` and `CLOUDFLARE_ACCOUNT_ID` for wrangler auth.
      6. **Deploy API preview** using `cloudflare/wrangler-action@v3`:
         - `workingDirectory: apps/api`
         - `command: deploy --name dt65-api-pr-${PR_NUM}`
         - Pass D1 database binding override via `--d1 DB=$D1_DB_ID` (or modify wrangler.jsonc dynamically)
      7. **Deploy Events preview** using `cloudflare/wrangler-action@v3`:
         - `workingDirectory: apps/events`
         - `command: deploy --name dt65-events-pr-${PR_NUM}`
      8. **Deploy WWW preview** using `cloudflare/wrangler-action@v3`:
         - `workingDirectory: apps/www`
         - `command: deploy --name dt65-www-pr-${PR_NUM}`
      9. **Comment preview URLs on PR** — Use `actions/github-script@v7` to create/update a comment with preview URLs for all 3 apps. Format:
         ```
         ### Preview Deployments
         - API: https://dt65-api-pr-{N}.{account}.workers.dev
         - Events: https://dt65-events-pr-{N}.{account}.workers.dev
         - WWW: https://dt65-www-pr-{N}.{account}.workers.dev
         ```

    **Important notes:**
    - Per-PR D1 database uses `wrangler d1 create` with `|| true` so re-runs on the same PR don't fail (database already exists).
    - The preview deploy uses separate Workers (not `--preview-alias`) per RESEARCH.md Open Question 2 recommendation — separate Workers with PR-number naming for full isolation including separate D1 bindings.
    - CI runs all checks on all apps for every PR (no path-based filtering) per user decision.
    - Use `CLOUDFLARE_API_TOKEN` secret (not `CLOUDFLARE_ACCOUNT_ID` as env var) — wrangler-action supports both. Set `CLOUDFLARE_ACCOUNT_ID` as env var in job.
    - The PR comment should be idempotent — update existing comment on re-push, don't create duplicates. Use a hidden marker comment to find/update: `<!-- dt65-preview-urls -->`.
  </action>
  <verify>
    Verify the YAML is valid: `python3 -c "import yaml; yaml.safe_load(open('.github/workflows/pr-checks.yml'))"` (or equivalent).
    Check that the workflow triggers on `pull_request` to `main`.
    Check that quality job runs all 6 checks: biome, tsc, knip, sherif, test, build.
    Check that preview-deploy job depends on quality job.
    Check that D1 database creation uses PR number in name.
    Check that all 3 apps get preview deploys with PR-numbered names.
  </verify>
  <done>
    `.github/workflows/pr-checks.yml` exists with valid YAML. Quality job runs all checks (lint, typecheck, knip, sherif, test, build). Preview deploy job creates per-PR D1, deploys all 3 apps as separate preview Workers, and comments preview URLs on the PR.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create PR cleanup and production deploy workflows</name>
  <files>
    .github/workflows/pr-cleanup.yml
    .github/workflows/deploy.yml
  </files>
  <action>
    Create the remaining 2 workflow files.

    **1. `.github/workflows/pr-cleanup.yml` — Clean up preview resources:**

    **Trigger:** `pull_request` targeting `main` with type `closed` (fires on both merge and close).

    **Job: `cleanup`**
    - `runs-on: ubuntu-latest`, `timeout-minutes: 5`
    - Environment variables: `PR_NUM: ${{ github.event.pull_request.number }}`
    - Required secrets: `CLOUDFLARE_API_TOKEN`, `CLOUDFLARE_ACCOUNT_ID`
    - Steps:
      1. `actions/checkout@v4`
      2. `pnpm/action-setup@v4`
      3. `actions/setup-node@v4` with `node-version: 22`, `cache: pnpm`
      4. `pnpm install --frozen-lockfile`
      5. **Delete preview Workers:**
         ```bash
         npx wrangler delete --name "dt65-api-pr-${PR_NUM}" --force 2>/dev/null || true
         npx wrangler delete --name "dt65-events-pr-${PR_NUM}" --force 2>/dev/null || true
         npx wrangler delete --name "dt65-www-pr-${PR_NUM}" --force 2>/dev/null || true
         ```
      6. **Delete per-PR D1 database:**
         ```bash
         DB_NAME="dt65-pr-${PR_NUM}"
         DB_ID=$(npx wrangler d1 list --json | jq -r ".[] | select(.name == \"$DB_NAME\") | .uuid")
         if [ -n "$DB_ID" ] && [ "$DB_ID" != "null" ]; then
           npx wrangler d1 delete "$DB_NAME" -y 2>/dev/null || true
         fi
         ```

    Use `|| true` on every delete command so the workflow doesn't fail if resources were already cleaned up or never created.

    **2. `.github/workflows/deploy.yml` — Production deploy on merge:**

    **Trigger:** `push` to `main` branch.

    **Job 1: `checks`** — Run full quality checks before deploying
    - `runs-on: ubuntu-latest`, `timeout-minutes: 15`
    - Steps: Same as PR checks quality job (checkout, setup pnpm/node, install, biome check, tsc --build, knip, sherif, test, build)

    **Job 2: `deploy`** — Deploy all 3 apps to production
    - `needs: checks`
    - `runs-on: ubuntu-latest`, `timeout-minutes: 10`
    - Required secrets: `CLOUDFLARE_API_TOKEN`, `CLOUDFLARE_ACCOUNT_ID`
    - Steps:
      1. `actions/checkout@v4`
      2. `pnpm/action-setup@v4`
      3. `actions/setup-node@v4` with `node-version: 22`, `cache: pnpm`
      4. `pnpm install --frozen-lockfile`
      5. **Deploy API** using `cloudflare/wrangler-action@v3`:
         - `workingDirectory: apps/api`
         - `command: deploy`
      6. **Deploy Events** using `cloudflare/wrangler-action@v3`:
         - `workingDirectory: apps/events`
         - `command: deploy`
      7. **Deploy WWW** using `cloudflare/wrangler-action@v3`:
         - `workingDirectory: apps/www`
         - `command: deploy`

    **Important notes:**
    - Deploy workflow runs full checks again even though PR checks already passed — this catches any issues from rebased/merged code.
    - Deploy all 3 apps on every merge (not path-based triggers) per user decision.
    - Production deploy uses wrangler.jsonc names directly (dt65-api, dt65-events, dt65-www).
    - Rebase merging only per user decision — branch protection settings are configured in GitHub UI (not in workflow files). Note this for the checkpoint.
  </action>
  <verify>
    Verify both YAML files are valid: `python3 -c "import yaml; yaml.safe_load(open('.github/workflows/pr-cleanup.yml'))"` and same for deploy.yml.
    Check pr-cleanup triggers on `pull_request: types: [closed]`.
    Check deploy triggers on `push: branches: [main]`.
    Check deploy runs quality checks before deploying.
    Check all 3 apps are deployed in both cleanup and deploy workflows.
  </verify>
  <done>
    `.github/workflows/pr-cleanup.yml` cleans up all 3 preview Workers and per-PR D1 database on PR close. `.github/workflows/deploy.yml` runs full quality checks then deploys all 3 apps to production on merge to main. Both files have valid YAML syntax.
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <name>Task 3: Verify CI/CD workflows and configure GitHub repository</name>
  <files>
    .github/workflows/pr-checks.yml
    .github/workflows/pr-cleanup.yml
    .github/workflows/deploy.yml
  </files>
  <action>
    Human verification checkpoint. Claude has created 3 GitHub Actions workflow files:
    1. `pr-checks.yml` — Quality checks + preview deploy with per-PR D1
    2. `pr-cleanup.yml` — Preview resource cleanup on PR close
    3. `deploy.yml` — Production deploy on merge to main

    The user needs to:
    1. Review the 3 workflow files in `.github/workflows/` for correctness
    2. In GitHub repository settings, configure:
       a. **Branch protection** for `main`:
          - Require status checks to pass before merging — select the `quality` job
          - Require branches to be up to date before merging
          - Allow rebase merging ONLY (disable merge commits and squash merging)
       b. **Repository secrets** (Settings > Secrets and variables > Actions):
          - `CLOUDFLARE_API_TOKEN` — API token with Workers + D1 permissions
          - `CLOUDFLARE_ACCOUNT_ID` — Cloudflare account ID
    3. Push a test branch and open a PR to verify:
       - Quality checks run and pass
       - Preview Workers are deployed (or fail gracefully if Cloudflare not yet configured)
    4. Set git config: `git config pull.rebase true` (per user decision)
  </action>
  <verify>
    User confirms workflows are correct and GitHub repository settings are configured.
    Type "approved" if workflows look correct and GitHub settings are configured, or describe any issues.
  </verify>
  <done>
    GitHub repository has branch protection (rebase-only, required status checks) and Cloudflare secrets configured. Workflows are reviewed and approved by user.
  </done>
</task>

</tasks>

<verification>
After all tasks complete and checkpoint is approved:

1. `.github/workflows/pr-checks.yml` — Valid workflow, triggers on PR to main
2. `.github/workflows/pr-cleanup.yml` — Valid workflow, triggers on PR close
3. `.github/workflows/deploy.yml` — Valid workflow, triggers on push to main
4. PR checks run: lint, typecheck, knip, sherif, test, build, preview deploy
5. PR cleanup deletes preview Workers and PR D1 database
6. Deploy runs checks then deploys all 3 apps to production
7. GitHub branch protection enforces rebase-only merging and required status checks
</verification>

<success_criteria>
- 3 workflow files exist with valid YAML in `.github/workflows/`
- PR checks workflow runs all 6 quality checks and deploys 3 preview Workers
- PR checks workflow creates per-PR D1 database
- PR cleanup workflow deletes all preview resources on PR close
- Deploy workflow runs checks then deploys all 3 apps on merge to main
- GitHub repository is configured with branch protection and required secrets
</success_criteria>

<output>
After completion, create `.planning/phases/01-monorepo-and-tooling/01-02-SUMMARY.md`
</output>
